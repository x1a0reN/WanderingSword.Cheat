
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a cheat/internal mod for the game "逸剑风云决" (Wandering Sword) V1.24.32. It uses DLL injection via version.dll proxy hijacking combined with Unreal Engine 4 SDK to create an in-game cheat menu by hijacking the game's built-in settings panel.

## Rules

1. **Never Delete Any Files**: Under no circumstances shall any file be deleted or commands executed that would result in file deletion.
2. **Compile After Code Modifications**: Every time code modifications are made, the following compile command must be executed:
   ```bash
   & 'D:\Program Files\Visual Studio 2026\MSBuild\Current\Bin\MSBuild.exe' 'D:\Projects\WanderingSword.Cheat\Inject\Wandering_Sword_Inject.vcxproj' /t:Build /p:Configuration=Release /p:Platform=x64 /m:1
   ```
   If a DLL is being used and an error occurs stating that the DLL is occupied, stop the process and notify me.
3. **Automatic Chinese GitHub Commit**: After modifying any code, automatically submit a commit to GitHub in Chinese. **Do not include a signature in the commit.**
4. **Do Not Modify Existing Correct Code**: Do not modify previously correct code unless necessary for implementing a new feature. If modification of existing code is required, it must be explicitly mentioned, as changes could potentially introduce errors in previously correct functionality.


## Build Commands

```bash
# Build the DLL
cd Inject
"/d/Program Files/Visual Studio 2026/MSBuild/Current/Bin/MSBuild.exe" Wandering_Sword_Inject.vcxproj //t:Build //p:Configuration=Release //p:Platform=x64 //m:1
```

Output: `Injectd\Release\Wandering_Sword_Inject.dll`

## Architecture

### Injection Flow
1. `DllMain` → `CreateThread(MainThread)`
2. `MainThread`: Allocate console → Hook GVC PostRender VTable → Key loop
3. `HookedGVCPostRender`: Per-frame execution, handles HOME key toggle, button click detection

### Core Hooks
- **GVC PostRender Hook**: VTable hook on `UGameViewportClient::PostRender` at index `Offsets::GVCPostRenderIdx`
- Used for per-frame logic (key detection, UI state sync)

### Panel Lifecycle
``` id="9vycfd"
HOME pressed → ToggleInternalWidget()
  ├─ Show: CreateInternalWidgetInstance() → AddToViewport → InitializeConfigView2BySDK → ApplyConfigView2TextPatch → SetGamePaused(true)
  └─ Hide: RemoveFromParent() → SetGamePaused(false) → Cleanup cache
```

## Key Source Files

| File | Purpose |
|------|---------|
| `Inject/Main.cpp` | Entry point, DLL main, key handling loop |
| `Inject/FrameHook.cpp` | GVC PostRender hook, UI polling |
| `Inject/TabContent.cpp` | Tab UI content (Tab0 character editing, Tab1 items) |
| `Inject/WidgetFactory.cpp` | UI widget creation helpers |
| `Inject/PanelManager.cpp` | Panel lifecycle management |
| `Inject/CheatState.cpp` | Cheat state persistence |

## Important Patterns

### SDK Usage
- Use SDK member functions (e.g., `GetOptionCount()`, `GetSelectedIndex()`) instead of raw memory access
- UE4 SDK classes are in `SDK/` directory (generated by Dumper-7)

### UI Controls
- **Dropdown**: `UBPVE_JHConfigVideoItem2_C` (CB_Main ComboBox + TXT_Title)
- **Slider**: `UBPVE_JHConfigVolumeItem2_C` (VolumeSlider + BTN_Minus/Plus + TXT_CurrentValue)
- **Toggle**: Dropdown with options "关/开" (no CheckBox in SDK)

### Performance Considerations
- Use throttled polling (100ms interval) for slider/dropdown detection
- Use focus caching to reduce per-frame keyboard focus scans
- Tab0 character editing uses `PollTab0CharacterInput` with various polling optimizations

## Hotkeys
- **HOME**: Toggle cheat menu display/hide
- **DELETE**: Unload DLL

## Important Notes
- The project uses Chinese comments and output
- 进度.md contains detailed development progress and pitfalls
- 轮询点与掉帧分析.md contains performance analysis for UI polling

## Inline Hook 坑点记录

在实现物品不减功能（地址：`JH-Win64-Shipping.exe+1206A70`）时遇到的坑点：

### 1. 必须使用跳板内存
**错误做法**: 直接覆盖原地址的字节
```cpp
// 错误！直接在原地址写入jmp，但原地址后续的指令会被破坏
memcpy(address, jmp_instruction, 5);
```

**正确做法**: 使用 `VirtualAlloc` 分配可执行内存作为跳板
```cpp
GHookTrampoline = VirtualAlloc(nullptr, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
```

### 2. 正确计算相对跳转偏移量
x64 near jmp 指令格式: `E9 xx xx xx xx` (相对偏移)
```cpp
// 正确公式: offset = target - (current + 5)
int32_t JmpOffset = reinterpret_cast<uintptr_t>(Trampoline) - (Address + 5);
memcpy(&JmpInstruction[1], &JmpOffset, 4);
```

### 3. 默认不安装 Hook
**错误**: DLL加载时直接安装hook，导致功能未启用也被hook

**正确**: 只初始化（保存原始字节、分配跳板），不安装hook。只有在用户启用功能时才调用 `EnableItemNoDecreaseHook()`

### 4. 正确还原 Hook
禁用功能时必须恢复原始字节：
```cpp
void DisableItemNoDecreaseHook() {
    if (!GInlineHookInstalled) return;
    DWORD OldProtect;
    VirtualProtect(address, 14, PAGE_EXECUTE_READWRITE, &OldProtect);
    memcpy(address, GOriginalChangeItemNumBytes, 5);  // 还原原始字节
    VirtualProtect(address, 14, OldProtect, &OldProtect);
    GInlineHookInstalled = false;
}
```

### 5. 动态启用/禁用逻辑
在FrameHook中根据开关状态动态控制：
```cpp
if (Config.ItemNoDecrease != LastItemNoDecrease) {
    if (Config.ItemNoDecrease)
        EnableItemNoDecreaseHook();
    else
        DisableItemNoDecreaseHook();
    LastItemNoDecrease = Config.ItemNoDecrease;
}
```

### 6. 正确的Inline Hook流程
```
原地址:
  jmp 跳板1地址       ; 跳过原始指令，跳转到跳板

跳板1地址 (执行hook逻辑):
  cmp r8d, 0         ; 检查参数
  jge +N             ; 条件跳转跳过
  xor r8d, r8d       ; 修改参数
  jmp 原地址+5       ; 跳回原函数继续执行
```

关键点：
- 原地址只写5字节jmp跳到跳板1
- 跳板1执行hook逻辑后，必须jmp回原地址+5（不是跳回跳板1内部！）
- 跳板1中可能需要保存/恢复寄存器（如 `mov [rsp+08],rbx`）

### 7. 使用 InlineHook.hpp 封装库
项目提供了 `InlineHook.hpp` 封装库（与 `VTHook.hpp` 同级），使用示例：
```cpp
#include "InlineHook.hpp"

static InlineHook::InlineHook ItemNoDecreaseHook;

// 初始化（获取模块地址、分配跳板）
ItemNoDecreaseHook.Init("JH-Win64-Shipping.exe", 0x1206A70);

// 设置跳板代码
unsigned char TrampolineCode[] = {
    0x48, 0x89, 0x5C, 0x24, 0x08,  // mov [rsp+08], rbx
    0x41, 0x83, 0xF8, 0x00,         // cmp r8d, 0
    0x0F, 0x8D, 0x03, 0x00, 0x00,  // jge +3
    0x45, 0x31, 0xC0,                // xor r8d, r8d
    0xE9, 0x00, 0x00, 0x00, 0x00    // jmp back (填充偏移)
};
// 设置跳转回原函数的偏移
int32_t BackOffset = InlineHook::InlineHook::CalcJmpBackOffset(TrampolineAddr, sizeof(TrampolineCode)-5, TargetAddr);
ItemNoDecreaseHook.SetTrampolineCode(TrampolineCode, sizeof(TrampolineCode));

// 安装 Hook
ItemNoDecreaseHook.Install();

// 卸载 Hook
ItemNoDecreaseHook.Remove();
```

### 8. x64 调用约定
- 参数顺序: rcx, rdx, r8, r9 (第1-4个参数)
- 第5+参数使用栈传递
- 64位指令需要用 `0x41` 前缀访问 r8-r15 寄存器