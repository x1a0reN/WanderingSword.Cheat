# 逸剑风云决游戏修改器 - 轮询点与掉帧分析文档

> 文档版本: 2026-03-02 (更新)
> 游戏: 逸剑风云决 (Wandering Sword)
> 引擎: Unreal Engine 4.26.2

---

## ⚠️ 重点发现：Tab0（角色面板）是主要掉帧原因

根据用户反馈：**打开Tab0角色面板时，FPS从80掉到60**，而其他Tab都能保持80FPS。

经过代码分析，发现Tab0包含**巨量编辑框控件**，每帧都要进行大量安全检查和状态检测。

---

## 一、Hook 入口点

### 1.1 主 Hook: `HookedGVCPostRender`

| 属性 | 值 |
|------|-----|
| 位置 | FrameHook.cpp:91 |
| 触发时机 | 每帧 PostRender 阶段 |
| 作用域 | 只要游戏运行就执行 |

**调用链**:
```
HookedGVCPostRender()
├── OriginalGVCPostRender()           // 调用原函数 (保留正常渲染)
├── DrawFpsOverlay()                 // 绘制FPS显示
├── World/Level Transition Guard     // 世界切换保护
├── EnsureLiveInternalWidgetForFrame() // 验证内部控件有效性
├── 键盘 HOME 键检测
├── PollTab0CharacterInput()         // 角色Tab轮询
├── 关闭按钮检测
├── 物品Browser轮询                  // (仅物品Tab)
├── Hover Tips 轮询                 // (已禁用)
├── 动态Tab按钮检测                 // (任何Tab)
└── 外部关闭检测
```

---

## 二、所有轮询点详细清单

### 轮询点总览表

| # | 轮询点 | 触发条件 | 触发频率 | 代码位置 | 备注 |
|---|--------|----------|----------|----------|------|
| 1 | FPS 绘制 | 游戏运行 | 每帧 | FrameHook.cpp:99 | |
| 2 | 角色Tab输入轮询 | 面板可见 | 每帧 | FrameHook.cpp:175 | Tab0激活时完整执行 |
| 3 | 关闭按钮检测 | 面板可见 | 每帧 | FrameHook.cpp:177-213 | 跨Tab执行 |
| 4 | 物品Browser主轮询 | 物品Tab | ~60Hz (16ms) | FrameHook.cpp:215-481 | 最重量级 |
| 5 | Hover Tips 轮询 | 面板可见 | 20-80ms | FrameHook.cpp:494-523 | **已禁用** |
| 6 | 动态Tab按钮检测 | 面板可见 | 每帧 | FrameHook.cpp:525-573 | 跨Tab执行 |
| 7 | 外部关闭检测 | 面板可见 | 每帧 | FrameHook.cpp:576-582 | |
| 8 | 可折叠面板轮询 | - | - | WidgetFactory.cpp:771 | **已禁用 (return;)** |

---

## 三、Tab0（角色面板）掉帧深度分析

### 3.1 Tab0 编辑框数量统计

Tab0 包含**大量编辑框控件**，每个控件每帧都要进行多项检测：

```
Tab0 编辑框数量统计:
┌─────────────────────────────────────────────────────────────────────┐
│ 分类                      │ 数量  │ 位置                         │
├───────────────────────────┼───────┼──────────────────────────────┤
│ 基础数值 (BaseBox)        │   7   │ 金钱/武学点/经脉点/etc      │
│ 属性 (AttrBox)           │  22   │ 气血/攻击/防御/暴击/etc     │
│ 恢复 (RecoverBox)         │   4   │ 气血恢复/真气恢复           │
│ 武器 (WeaponBox)         │  12   │ 拳掌/剑法/刀法/枪棍/暗器    │
│ 难度系数 (DiffBox)        │   7   │ 简单/普通/困难/极难系数     │
│ 称号门槛 (TitleBox)       │  12   │ 称号门槛1-11                │
│ 其他 (Limit/Extra/Exp)    │  ~20  │ 最大词条/战斗时间/锻造/etc │
├───────────────────────────┼───────┼──────────────────────────────┤
│ 总计                      │ ~80+  │                              │
└─────────────────────────────────────────────────────────────────────┘
```

**这就是掉帧的根本原因：80+ 个编辑框，每帧都要进行多次检测！**

---

### 3.2 Tab0 轮询代码详解

```cpp
// TabContent.cpp:2336 - PollTab0CharacterInput()
// 每帧执行流程:

void PollTab0CharacterInput(bool bTab0Active)
{
    // ===== 1. 清理失效的编辑框绑定 =====
    // GTab0Bindings.erase(...) - 遍历所有80+个绑定，删除失效的
    // 每帧执行: 80+ × IsSafeLiveObject()
    for (auto& Binding : GTab0Bindings)
    {
        IsSafeLiveObject(Binding.Edit)  // × 80+
    }

    // ===== 2. Tab0激活时的完整轮询 =====
    if (bTab0Active)  // 打开Tab0时为true
    {
        // 2.1 滑块轮询 - 3个滑块
        PollTab0RatioSliders(PC);
        //   每滑块: IsSafeLiveObject()×4 + IsPressed()×2 + GetValue()

        // 2.2 下拉框轮询 - 2个下拉框
        PollTab0RoleDropdowns(PC, true);
        //   GetComboSelectedIndex() × 2

        // 2.3 焦点检测 - 遍历80+个编辑框
        for (auto& Binding : GTab0Bindings)  // × 80+
        {
            IsSafeLiveObject(Binding.Edit)   // × 80+
            HasKeyboardFocus()               // × 80+  ← UE4 内部实现复杂!
        }

        // 2.4 输入过滤 - 对有焦点的编辑框
        if (Focused && Focused->Edit)
        {
            GetText().ToString()            // × 1 (只有焦点那个)
            SanitizeNumericInputText()      // × 1
            SetText()                      // × 1 (值变化时)
        }

        // 2.5 回车提交处理
        if (EnterTriggered)
        {
            GetText().ToString()           // × 1
            SetText()                     // × 1
            strtod() / 数值解析            // × 1
            TrySetTab0FieldValue()        // × 1 ← 写入游戏内存
            RefreshTab0BindingsText()     // × 1 ← 刷新所有80+个框!
        }
    }
}
```

---

### 3.3 Tab0 每帧操作详细估算

| 操作 | 次数 | 说明 |
|------|------|------|
| IsSafeLiveObject (清理) | ~80 | 每帧清理失效绑定 |
| IsSafeLiveObject (焦点扫描) | ~80 | 焦点扫描 |
| HasKeyboardFocus() | ~80 | **最慢的操作！** UE4内部实现复杂 |
| GetText().ToString() | ~1 | 只对焦点编辑框 |
| SetText() | 0-80 | 值变化时刷新 |
| GetComboSelectedIndex() | 2 | 下拉框 |
| Slider操作 | 3×(4+2+1) | 3个滑块 |
| **总计** | **~240+/帧** | **这就是掉帧原因！** |

---

### 3.4 最致命的操作：HasKeyboardFocus()

```cpp
// TabContent.cpp:2381-2389
for (auto& Binding : GTab0Bindings)
{
    if (!Binding.Edit || !IsSafeLiveObject(static_cast<UObject*>(Binding.Edit)))
        continue;
    if (Binding.Edit->HasKeyboardFocus())  // ← 这是最慢的！
    {
        Focused = &Binding;
        break;
    }
}
```

**为什么 HasKeyboardFocus() 慢？**
- UE4 内部实现复杂，需要遍历控件树
- 每个编辑框都要调用一次
- 80+ 个编辑框 × 每帧 = 极其缓慢

---

### 3.5 RefreshTab0BindingsText() 是另一个性能杀手

```cpp
// TabContent.cpp:1992-2005
void RefreshTab0BindingsText(APlayerController* PC)
{
    FTab0HeroContext Ctx = BuildTab0HeroContext(PC);
    for (auto& Binding : GTab0Bindings)  // 遍历80+个绑定
    {
        if (!Binding.Edit || !IsSafeLiveObject(...))
            continue;

        // 对每个编辑框:
        // 1. 读取游戏内存 (GetMoney, GetSkillExp等)
        // 2. 数值格式化
        // 3. SetText() - 设置到UI
    }
}

// 触发时机:
// - 打开Tab0时
// - 按下回车提交时
// - 切换角色/下拉框选项时
```

**每次刷新80+个编辑框，涉及到：**
- 读取游戏内存 (多次SDK调用)
- 字符串格式化
- 80+ 次 SetText() UI调用

---

## 三、各轮询点详解

### 3.1 #1: FPS 绘制 (每帧执行)

```cpp
// FrameHook.cpp:45-88
void DrawFpsOverlay(UCanvas* CanvasObj)
{
    // 每帧执行的操作:
    // 1. IsSafeLiveObjectOfClass(CanvasObj)    // 安全检查
    // 2. IsSafeLiveObject(Engine)             // 获取引擎
    // 3. GetTickCount64()                      // 时间获取
    // 4. K2_DrawText()                         // 绘制文字 ← GPU操作
}
```

**性能影响**: 低 - 仅有一次 DrawText 调用

---

### 3.2 #2: 角色Tab输入轮询 (PollTab0CharacterInput)

```cpp
// FrameHook.cpp:175
PollTab0CharacterInput(IsCharacterTabActive);
```

| 阶段 | 执行操作 | 频率 |
|------|----------|------|
| 总是执行 | GTab0Bindings 清理 (IsSafeLiveObject检查) | 每帧 |
| 非Tab0 | 提前返回，跳过主要处理 | - |
| Tab0激活 | PollTab0RatioSliders() - 3个滑块轮询 | 每帧 |
| Tab0激活 | PollTab0RoleDropdowns() - 下拉框轮询 | 每帧 |
| Tab0激活 | 编辑框焦点检测 | 每帧 |
| Tab0激活 | Enter键提交处理 | 每帧 |

**位置**: TabContent.cpp:2336

**跨Tab行为**:
- ❌ 总是被调用
- ✅ 非Tab0时提前返回，只执行清理工作

---

### 3.3 #3: 关闭按钮检测 (每帧执行)

```cpp
// FrameHook.cpp:177-213
const bool CanCheckExit =
    InternalWidgetVisible &&
    LiveInternalWidget &&
    LiveInternalWidget->IsInViewport() &&
    LiveInternalWidget->IsA(UBPMV_ConfigView2_C::StaticClass());

if (CanCheckExit)
{
    IsSafeLiveObject(ExitObj)   // × 1
    IsPressed()                  // × 1
}
```

**跨Tab行为**: ✅ 任何Tab都执行

---

### 3.4 #4: 物品Browser主轮询 (最重量级)

```cpp
// FrameHook.cpp:215-481
if (InternalWidgetVisible && LiveInternalWidget && IsItemsTabActive)
{
    if (RunItemUiPoll)  // 16ms 间隔
    {
        // 4.1 PollCollapsiblePanelsInput()      // 已禁用
        // 4.2 滑块控件轮询 (6-10个滑块)
        // 4.3 物品缓存构建 (仅一次)
        // 4.4 分类下拉框检测
        // 4.5 翻页按钮检测
        // 4.6 物品格子点击检测 (24格子)
        // 4.7 网格命中计算
    }
}
```

#### 3.4.1 滑块控件轮询 (每滑块)

```cpp
// FrameHook.cpp:235-307
for (size_t i = 0; i < GVolumeItems.size(); ++i)  // 约6-10个
{
    // 安全检查 (4次/滑块)
    IsSafeLiveObject(Item)       // ×1
    IsSafeLiveObject(Slider)    // ×1
    IsSafeLiveObject(BTN_Minus) // ×1
    IsSafeLiveObject(BTN_Plus)  // ×1

    // 状态检测 (2次/滑块)
    BTN_Minus->IsPressed()      // ×1
    BTN_Plus->IsPressed()       // ×1

    // 值操作 (1-2次/滑块)
    Slider->GetValue()          // ×1
    Slider->SetValue()          // 变化时
    TXT_CurrentValue->SetText() // 变化时
}

// 每次滑块轮询总操作数: 6-8次 IsSafeLiveObject + 2次 IsPressed + 1次 GetValue
// 假设8个滑块: 64次 IsSafeLiveObject + 16次 IsPressed + 8次 GetValue = 88次/轮询周期
```

#### 3.4.2 分类下拉框检测

```cpp
// FrameHook.cpp:334-344
GItemCategoryDD->CB_Main->GetSelectedIndex()  // ×1
FilterItems()                                  // ×1 (分类过滤)
RefreshItemPage()                              // ×1 (触发!) ← 最重量级
```

#### 3.4.3 翻页按钮检测

```cpp
// FrameHook.cpp:356-376
IsSafeLiveObject(PrevInner) × 2
PrevInner->IsPressed() × 1
IsSafeLiveObject(NextInner) × 2
NextInner->IsPressed() × 1
RefreshItemPage()  // 每次翻页触发 ← 最重量级
```

#### 3.4.4 物品格子点击检测 (24格子)

```cpp
// FrameHook.cpp:397-410
for (int32 i = 0; i < 24; i++)
{
    IsSafeLiveObject(Btn)  // ×24
    Btn->IsPressed()       // ×24
}
// 总计: 48次/轮询周期
```

#### 3.4.5 网格命中计算

```cpp
// FrameHook.cpp:412-460
ResolveHoveredGridSlot():
    IsSafeLiveObject(GridPanel) ×1
    GetCachedGeometry() ×1           // 获取网格几何
    GetLocalSize() ×1               // 获取尺寸
    LocalToViewport() ×2             // 坐标转换 ×2
    GetMousePositionOnViewport() ×1  // 获取鼠标位置
// 只要鼠标在物品Tab就每帧执行
```

---

### 3.5 #5: Hover Tips 轮询 (已禁用)

```cpp
// FrameHook.cpp:494-523
// 临时禁用：用于验证物品 Tab 悬浮 Tip 轮询是否为卡顿主因
// PollItemBrowserHoverTips();
```

**状态**: ⚠️ **已禁用** - 注释说明用于验证卡顿原因

**原频率**:
- 物品Tab内: 20-33ms (30-50Hz)
- 其他Tab: 80ms (12.5Hz)

---

### 3.6 #6: 动态Tab按钮检测 (每帧执行)

```cpp
// FrameHook.cpp:525-573
if (InternalWidgetVisible && LiveConfigView)
{
    // 6个原生Tab按钮 + 3个动态Tab按钮
    IsSafeLiveObject(TabBtn) × 9
    IsHovered() × 9

    // 切换时调用
    ShowDynamicTab()  // 切换动态Tab
    ShowOriginalTab() // 切回原生Tab
}
```

**跨Tab行为**: ✅ 任何Tab都执行

---

### 3.7 #7: 外部关闭检测

```cpp
// FrameHook.cpp:576-582
if (InternalWidgetVisible && LiveInternalWidget && !LiveInternalWidget->IsInViewport())
{
    HideInternalWidget(PC);
}
```

---

### 3.8 #8: 可折叠面板轮询 (已禁用)

```cpp
// WidgetFactory.cpp:771
void PollCollapsiblePanelsInput()
{
    // 临时停用：不再监听/切换 CollapsibleToggle，降低每帧轮询负担。
    return;  // ← 直接返回，什么都不做
}
```

**状态**: ⚠️ **已禁用**

---

## 四、掉帧原因分析

### 4.1 按影响排序的性能瓶颈

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  排名   │ 严重程度 │ 位置                    │ 原因                        │
├─────────┼──────────┼────────────────────────┼─────────────────────────────┤
│   1     │  极严重  │ RefreshItemPage()      │ 24格子×多个UI操作+纹理加载  │
│   2     │   严重   │ 滑块控件轮询           │ 6-10滑块×8次IsSafeLiveObject│
│   3     │   中等   │ 物品格子安全检查       │ 24×2次IsSafeLiveObject     │
│   4     │   中等   │ 网格命中计算           │ 坐标转换+鼠标位置获取      │
│   5     │   轻微   │ 动态Tab按钮检测       │ 9个按钮IsHovered           │
│   6     │   轻微   │ 关闭按钮检测           │ 1个按钮IsPressed           │
│   7     │   极低   │ FPS绘制                │ 1次DrawText                │
│   8     │   N/A    │ Hover Tips             │ 已禁用                     │
│   9     │   N/A    │ 可折叠面板             │ 已禁用                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 RefreshItemPage() 详细分析

这是最重量级的函数，每次调用执行:

```cpp
// ItemBrowser.cpp:609-771
void RefreshItemPage()
{
    // 24个格子循环
    for (int32 i = 0; i < 24; i++)
    {
        // 4.1 安全检查 (4次/格子)
        IsSafeLiveObjectOfClass(Btn)      // ×1
        IsSafeLiveObjectOfClass(Img)       // ×1
        IsSafeLiveObjectOfClass(Border)   // ×1
        IsSafeLiveObject(EntryWidget)     // ×1

        // 4.2 基础UI设置 (6-8次/格子)
        SetIsEnabled(true/false)          // ×2
        SetVisibility()                   // ×3
        SetToolTipText()                  // ×1

        // 4.3 纹理相关 (最慢!)
        ResolveTextureFromSoftData()      // ×1 (可能触发纹理加载!)
        SetBrushFromTexture()            // ×1 (GPU操作)

        // 4.4 品质相关
        GetColorByQuality()              // ×1
        GetItemQualityBorderTexture()    // ×1
        SetColorAndOpacity()             // ×2

        // 4.5 清理操作
        SetVisibility(Collapsed)         // 格子为空时
    }

    // 4.6 页码显示
    SetText()                           // ×1

    // 4.7 翻页按钮状态
    SetIsEnabled()                      // ×2
    GotoNormalStatus() / GotoDisableStatus() // ×2
}

// 单次 RefreshItemPage 总操作:
// - 安全检查: 24 × 4 = 96次
// - 基础UI: 24 × 6 = 144次
// - 纹理操作: 24 × 2 = 48次
// - 品质操作: 24 × 4 = 96次
// - 其他: ~10次
// 总计: ~400次 UI 方法调用 + 最多24次纹理加载
```

**触发时机**:
- 分类切换时 (分类下拉框变化)
- 翻页时 (点击上一页/下一页)

---

### 4.3 每帧总操作估算

| 场景 | 物品Tab活跃 | 物品Tab + 翻页 | 角色Tab |
|------|-------------|-----------------|---------|
| IsSafeLiveObject | ~140 | ~140 | ~20 |
| IsPressed/IsHovered | ~50 | ~50 | ~5 |
| GetValue/SetValue | ~20 | ~20 | ~10 |
| SetText/SetVisibility | ~30 | ~430+ | ~10 |
| 纹理相关操作 | ~50 | ~50 | 0 |
| **总操作估计** | **~290/帧** | **~700+/帧** | **~45/帧** |

---

## 五、轮询频率汇总

| 轮询项 | 当前频率 | 说明 |
|--------|----------|------|
| 主轮询间隔 | 16ms | 物品Browser主轮询 |
| 滑块安全检查 | 16ms | 与主轮询同步 |
| 物品格子安全检查 | 16ms | 与主轮询同步 |
| 网格命中计算 | 16ms | 与主轮询同步 |
| Hover Tips | 20-80ms | **已禁用** |
| 角色Tab轮询 | 每帧 | 无节流 |
| 动态Tab检测 | 每帧 | 无节流 |
| 关闭按钮检测 | 每帧 | 无节流 |

---

## 六、Tab隔离情况

| Tab | 轮询项 | 是否隔离 |
|-----|--------|----------|
| Tab 0 (角色) | PollTab0CharacterInput | ✅ 基本隔离 (提前返回) |
| **Tab 1 (物品)** | **物品Browser轮询** | **✅ 完全隔离** |
| 所有Tab | 关闭按钮检测 | ❌ 跨Tab |
| 所有Tab | 动态Tab按钮检测 | ❌ 跨Tab |
| 所有Tab | 外部关闭检测 | ❌ 跨Tab |

---

## 七、已确认的性能优化

| 优化 | 状态 | 效果 |
|------|------|------|
| Hover Tips 轮询 | ❌ 已禁用 | 高 (原30-50Hz深度检测) |
| 可折叠面板轮询 | ❌ 已禁用 | 高 |
| 滑块值变化检测 | ✅ 已实现 | 避免无变化时SetValue |
| 按钮边缘触发 | ✅ 已实现 | 避免重复触发 |
| 主轮询16ms节流 | ✅ 已实现 | 限制60Hz |

---

## 八、建议优化方向

### 优先级 P0 (立即可做)

1. **滑块/格子安全检查降频**
   - 16ms → 200ms
   - 影响: 减少每帧 IsSafeLiveObject 调用

2. **网格命中计算降频**
   - 16ms → 33ms 或更慢
   - 影响: 减少坐标转换调用

### 优先级 P1 (短期)

3. **RefreshItemPage 优化**
   - 添加 UI 状态缓存，只设置变化的项
   - 纹理异步加载

4. **禁用网格命中兜底逻辑**
   - 只保留按钮 IsPressed 检测

### 优先级 P2 (长期)

5. **使用游戏原生事件系统**
   - 替代轮询检测按钮点击
   - 利用 Slider 的 OnValueChanged 事件

---

## 九、调试建议

当前代码已添加 FPS 显示功能 (FrameHook.cpp:45-88)，可用于验证优化效果:

```
左上角显示: FPS: xx.x
```

掉帧时的调试步骤:
1. 打开物品Tab，观察FPS
2. 切换分类，观察FPS变化
3. 翻页，观察FPS峰值
4. 移动鼠标划过物品格子，观察FPS

---

## 十一、Tab0 编辑功能保留的优化方案（完整版）

### 11.1 优化策略：分层轮询 + 缓存 + 变化检测

```
核心思想：
1. 将"每帧都要做"和"只在变化时做"分开
2. 使用缓存减少重复计算
3. 对不同操作使用不同频率
```

### 11.2 详细优化方案

#### 优化1: 分离清理和焦点扫描

**当前问题**: 每帧都遍历80+个编辑框做两件事
- 清理失效绑定 (IsSafeLiveObject × 80)
- 扫描焦点 (HasKeyboardFocus × 80)

**优化方案**: 分离这两个操作，使用不同频率

```cpp
// ===== 优化后的代码结构 =====

void PollTab0CharacterInput(bool bTab0Active)
{
    const DWORD NowTick = GetTickCount();

    // ==== A. 清理操作：每50帧做一次 ====
    static DWORD sLastCleanupTick = 0;
    if (NowTick - sLastCleanupTick >= 50)  // 50ms = 20Hz
    {
        sLastCleanupTick = NowTick;
        // 只做清理，不扫描焦点
        CleanupTab0Bindings();
    }

    // ==== B. 焦点扫描：使用缓存 + 事件触发 ====
    static UEditableTextBox* sCachedFocusedEdit = nullptr;
    static DWORD sLastFocusScanTick = 0;
    const bool NeedFocusScan =
        EnterTriggered ||  // 按下回车时需要扫描
        (GTab0LastFocusedEdit && !IsFocusStillValid(GTab0LastFocusedEdit)) ||  // 上次焦点失效
        (NowTick - sLastFocusScanTick >= 200);  // 每200ms保底扫描一次

    if (NeedFocusScan)
    {
        sLastFocusScanTick = NowTick;
        sCachedFocusedEdit = ScanFocusEdit();  // 只扫描，返回焦点控件
        if (sCachedFocusedEdit)
            GTab0LastFocusedEdit = sCachedFocusedEdit;
    }
    UEditableTextBox* Focused = sCachedFocusedEdit;

    // ==== C. Tab0激活时的其他操作 ====
    if (bTab0Active)
    {
        // 滑块轮询：保持16ms，但只处理 +/- 按钮点击
        PollTab0RatioSliders(PC);

        // 下拉框：只在变化时处理
        PollTab0RoleDropdowns(PC, true);

        // 输入处理：只对焦点编辑框
        if (Focused)
            HandleTab0Input(Focused, EnterTriggered, PC);
    }
}
```

---

#### 优化2: 焦点缓存 + 有效性检查

**当前问题**: HasKeyboardFocus() 每帧 × 80 被调用

**优化方案**: 缓存焦点，只在需要时重新扫描

```cpp
// 新增函数和变量

// 焦点缓存
static UEditableTextBox* sFocusedEditCache = nullptr;
static DWORD sFocusCacheTick = 0;
static const DWORD kFocusCacheDuration = 200; // 缓存200ms

// 检查焦点是否仍然有效
bool IsFocusStillValid(UEditableTextBox* Edit)
{
    if (!Edit || !IsSafeLiveObject(static_cast<UObject*>(Edit)))
        return false;
    return Edit->HasKeyboardFocus();
}

// 扫描焦点编辑框（优化版）
UEditableTextBox* ScanFocusEdit()
{
    // 1. 先检查缓存的焦点是否还有效
    if (sFocusedEditCache && IsFocusStillValid(sFocusedEditCache))
        return sFocusedEditCache;

    // 2. 缓存失效，才遍历扫描
    for (auto& Binding : GTab0Bindings)
    {
        if (!Binding.Edit || !IsSafeLiveObject(static_cast<UObject*>(Binding.Edit)))
            continue;
        if (Binding.Edit->HasKeyboardFocus())
        {
            sFocusedEditCache = Binding.Edit;
            sFocusCacheTick = GetTickCount();
            return Binding.Edit;
        }
    }

    // 3. 没有焦点
    sFocusedEditCache = nullptr;
    return nullptr;
}
```

---

#### 优化3: 编辑框清理优化

**当前问题**: 每帧都遍历80+个编辑框删除失效的

**优化方案**: 使用"标记-清理"两阶段方式

```cpp
// 清理操作优化版
void CleanupTab0Bindings()
{
    // 只删除明确失效的，不遍历全部
    // 使用"标记-删除"模式

    bool NeedsCleanup = false;
    for (auto& Binding : GTab0Bindings)
    {
        if (!Binding.Edit)
        {
            NeedsCleanup = true;
            break;
        }
    }

    if (!NeedsCleanup)
        return;  // 没有失效的，直接返回

    // 只有在需要时才真正删除
    GTab0Bindings.erase(
        std::remove_if(
            GTab0Bindings.begin(),
            GTab0Bindings.end(),
            [](const FTab0Binding& Binding)
            {
                return !Binding.Edit || !IsSafeLiveObject(static_cast<UObject*>(Binding.Edit));
            }),
        GTab0Bindings.end());
}
```

---

#### 优化4: RefreshTab0BindingsText 优化

**当前问题**: 按回车时刷新所有80+个编辑框

**优化方案**:
1. 首次打开Tab0时只刷新可见的
2. 使用增量刷新
3. 使用节流避免频繁刷新

```cpp
// 增量刷新：只刷新当前编辑框的值，不是全部
void RefreshSingleTab0Binding(FTab0Binding& Binding, APlayerController* PC)
{
    if (!Binding.Edit || !IsSafeLiveObject(static_cast<UObject*>(Binding.Edit)))
        return;

    double Value = 0;
    if (TryGetTab0FieldValue(Ctx, Binding.Field, &Value))
    {
        // 格式化并设置
        wchar_t Buf[32] = {};
        if (Binding.bInteger)
            swprintf_s(Buf, 32, L"%d", static_cast<int32>(Value));
        else
            swprintf_s(Buf, 32, L"%.1f", Value);

        Binding.Edit->SetText(MakeText(Buf));
    }
}

// 节流刷新：使用静态变量控制刷新频率
static DWORD sLastFullRefreshTick = 0;
void RefreshTab0BindingsTextThrottled(APlayerController* PC)
{
    DWORD NowTick = GetTickCount();
    if (NowTick - sLastFullRefreshTick < 100)  // 最多每100ms全刷新一次
        return;

    sLastFullRefreshTick = NowTick;
    RefreshTab0BindingsText(PC);  // 调用原有函数
}
```

---

#### 优化5: 滑块轮询优化

**当前问题**: 3个滑块每帧都完整检测

**优化方案**: 使用变化检测 + 边缘触发

```cpp
// 在 PollTab0RatioSliders 中优化
void PollTab0RatioSliders(APlayerController* PC)
{
    // 保持原有的 PollOne 调用
    // 但减少 SetText 调用次数

    static float sLastPercent[3] = {-1, -1, -1};
    static int sLastApplyResult[3] = {-1, -1, -1};

    // 每次 PollOne 后检查是否真的需要更新
    // UpdateVolumeItemPercentText 只在值变化时调用
}

// 或者更简单：让滑块自己处理，不需要每帧检测
// 玩家拖动滑块时自然会有反馈
```

---

### 11.3 完整优化代码示例

```cpp
// ===== TabContent.cpp 新增变量 =====
namespace
{
    // 清理节流
    DWORD sLastTab0CleanupTick = 0;
    const DWORD kTab0CleanupInterval = 50;  // 50ms

    // 焦点缓存
    UEditableTextBox* sFocusedEditCache = nullptr;
    DWORD sFocusCacheTick = 0;
    const DWORD kFocusCacheDuration = 200;  // 200ms

    // 刷新节流
    DWORD sLastTab0RefreshTick = 0;
    const DWORD kTab0RefreshInterval = 100;  // 100ms
}

// ===== 清理优化 =====
void CleanupTab0Bindings_Optimized()
{
    // 快速检查：先看是否有需要清理的
    bool hasInvalid = false;
    for (const auto& Binding : GTab0Bindings)
    {
        if (!Binding.Edit || !IsSafeLiveObject(static_cast<UObject*>(Binding.Edit)))
        {
            hasInvalid = true;
            break;
        }
    }

    if (!hasInvalid)
        return;

    GTab0Bindings.erase(
        std::remove_if(
            GTab0Bindings.begin(),
            GTab0Bindings.end(),
            [](const FTab0Binding& Binding)
            {
                return !Binding.Edit || !IsSafeLiveObject(static_cast<UObject*>(Binding.Edit));
            }),
        GTab0Bindings.end());
}

// ===== 焦点扫描优化 =====
bool IsFocusStillValid_Optimized()
{
    if (!sFocusedEditCache)
        return false;
    return IsSafeLiveObject(static_cast<UObject*>(sFocusedEditCache)) &&
           sFocusedEditCache->HasKeyboardFocus();
}

UEditableTextBox* ScanFocusEdit_Optimized()
{
    DWORD NowTick = GetTickCount();

    // 1. 检查缓存
    if (sFocusedEditCache && (NowTick - sFocusCacheTick) < kFocusCacheDuration)
    {
        if (IsSafeLiveObject(static_cast<UObject*>(sFocusedEditCache)) &&
            sFocusedEditCache->HasKeyboardFocus())
        {
            return sFocusedEditCache;
        }
    }

    // 2. 缓存失效，遍历扫描
    for (auto& Binding : GTab0Bindings)
    {
        if (!Binding.Edit || !IsSafeLiveObject(static_cast<UObject*>(Binding.Edit)))
            continue;
        if (Binding.Edit->HasKeyboardFocus())
        {
            sFocusedEditCache = Binding.Edit;
            sFocusCacheTick = NowTick;
            return Binding.Edit;
        }
    }

    sFocusedEditCache = nullptr;
    return nullptr;
}

// ===== 修改 PollTab0CharacterInput =====
void PollTab0CharacterInput(bool bTab0Active)
{
    DWORD NowTick = GetTickCount();

    // ==== 1. 清理：每50ms一次 ====
    if (NowTick - sLastTab0CleanupTick >= kTab0CleanupInterval)
    {
        sLastTab0CleanupTick = NowTick;
        CleanupTab0Bindings_Optimized();
    }

    // ==== 2. 检查上次焦点是否有效 ====
    if (GTab0LastFocusedEdit &&
        !IsSafeLiveObject(static_cast<UObject*>(GTab0LastFocusedEdit)))
    {
        GTab0LastFocusedEdit = nullptr;
    }

    // ==== 3. 键盘状态 ====
    const bool EnterDown = (GetAsyncKeyState(VK_RETURN) & 0x8000) != 0;
    const bool EnterTriggered = EnterDown && !GTab0EnterWasDown;
    if (!bTab0Active)
    {
        PollTab0RoleDropdowns(nullptr, false);
        GTab0EnterWasDown = EnterDown;
        GTab0LastFocusedEdit = nullptr;
        return;
    }

    // ==== 4. Tab0 激活时的操作 ====
    APlayerController* PC = nullptr;
    if (UWorld* World = UWorld::GetWorld())
        PC = UGameplayStatics::GetPlayerController(World, 0);

    // 4.1 滑块轮询 - 保持16ms
    PollTab0RatioSliders(PC);

    // 4.2 下拉框轮询
    PollTab0RoleDropdowns(PC, true);

    // 4.3 焦点扫描 - 使用缓存 + 事件触发
    UEditableTextBox* Focused = nullptr;
    const bool needFocusScan =
        EnterTriggered ||
        (GTab0LastFocusedEdit &&
         !IsSafeLiveObject(static_cast<UObject*>(GTab0LastFocusedEdit))) ||
        (NowTick - sFocusCacheTick >= kFocusCacheDuration);

    if (needFocusScan)
    {
        Focused = ScanFocusEdit_Optimized();
        if (Focused)
            GTab0LastFocusedEdit = Focused;
    }
    else if (GTab0LastFocusedEdit &&
             IsSafeLiveObject(static_cast<UObject*>(GTab0LastFocusedEdit)))
    {
        Focused = GTab0LastFocusedEdit;
    }

    // 4.4 输入处理
    if (Focused && Focused->Edit)
    {
        // ... 原有输入处理逻辑 ...
    }

    GTab0EnterWasDown = EnterDown;
}
```

---

### 11.4 优化效果预估

| 优化项 | 优化前 | 优化后 | 提升 |
|--------|--------|--------|------|
| 清理 IsSafeLiveObject | 80+/帧 | 每50ms一次 (~1.6/帧) | **50x** |
| 焦点 HasKeyboardFocus | 80+/帧 | 每200ms一次 + 事件触发 (~5/帧) | **16x** |
| RefreshTab0BindingsText | 80+ SetText | 100ms节流 | **6x** |
| **总计** | **~240+ 操作/帧** | **~20 操作/帧** | **12x** |

---

### 11.5 关键点总结

1. **分离清理和焦点扫描** - 两个操作使用不同频率
2. **焦点缓存** - 缓存焦点，200ms内不重复扫描
3. **事件触发** - 按下回车时强制扫描焦点
4. **节流刷新** - Refresh 操作使用100ms节流
5. **快速检查** - 清理前先快速判断是否有需要清理的

需要我帮你把这些优化代码实际应用到项目中吗？
