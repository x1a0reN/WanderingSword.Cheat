#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// VTable Hook utilities

#include <Windows.h>
#include "SDK/Basic.hpp"

namespace SDK
{

namespace InSDKUtils
{
	template<typename FuncType>
	inline FuncType SetVirtualFunction(void* ObjectInstance, int32 Index, FuncType NewFunction)
	{
		void** VTable = *reinterpret_cast<void***>(ObjectInstance);
		void* Original = VTable[Index];

		DWORD OldProtect;
		if (!VirtualProtect(&VTable[Index], sizeof(void*), PAGE_EXECUTE_READWRITE, &OldProtect))
			return nullptr;

		VTable[Index] = reinterpret_cast<void*>(NewFunction);
		VirtualProtect(&VTable[Index], sizeof(void*), OldProtect, &OldProtect);

		return reinterpret_cast<FuncType>(Original);
	}
}

/*
* Class-level VTable hook utility.
*
* WARNING: This modifies the original vtable slot shared by ALL instances of the class.
* Every object of this class (and its subclasses) will be affected by the hook.
* If you need per-instance hooking, use a shadow vtable approach instead.
*
* Usage:
*   VTableHook Hook(SomeObject, Offsets::GVCPostRenderIdx);
*   auto Original = Hook.Install<void(*)(void*, void*)>(MyHookFunction);
*   // ... later ...
*   Hook.Remove();  // or let RAII handle it
*/
class VTableHook
{
private:
	void** VTable = nullptr;
	int32 Index = -1;
	void* OriginalFunction = nullptr;
	bool bInstalled = false;

public:
	VTableHook() = default;

	VTableHook(void* ObjectInstance, int32 VTableIndex)
		: VTable(*reinterpret_cast<void***>(ObjectInstance))
		, Index(VTableIndex)
		, OriginalFunction(nullptr)
		, bInstalled(false)
	{
	}

	~VTableHook()
	{
		Remove();
	}

	VTableHook(const VTableHook&) = delete;
	VTableHook& operator=(const VTableHook&) = delete;

	VTableHook(VTableHook&& Other) noexcept
		: VTable(Other.VTable)
		, Index(Other.Index)
		, OriginalFunction(Other.OriginalFunction)
		, bInstalled(Other.bInstalled)
	{
		Other.VTable = nullptr;
		Other.Index = -1;
		Other.OriginalFunction = nullptr;
		Other.bInstalled = false;
	}

	VTableHook& operator=(VTableHook&& Other) noexcept
	{
		if (this != &Other)
		{
			Remove();

			VTable = Other.VTable;
			Index = Other.Index;
			OriginalFunction = Other.OriginalFunction;
			bInstalled = Other.bInstalled;

			Other.VTable = nullptr;
			Other.Index = -1;
			Other.OriginalFunction = nullptr;
			Other.bInstalled = false;
		}
		return *this;
	}

	template<typename FuncType>
	FuncType Install(FuncType HookFunction)
	{
		if (bInstalled || !VTable || Index < 0)
			return nullptr;

		OriginalFunction = VTable[Index];

		DWORD OldProtect;
		if (!VirtualProtect(&VTable[Index], sizeof(void*), PAGE_EXECUTE_READWRITE, &OldProtect))
			return nullptr;

		VTable[Index] = reinterpret_cast<void*>(HookFunction);
		VirtualProtect(&VTable[Index], sizeof(void*), OldProtect, &OldProtect);

		bInstalled = true;
		return reinterpret_cast<FuncType>(OriginalFunction);
	}

	bool Remove()
	{
		if (!bInstalled || !VTable || Index < 0)
			return false;

		DWORD OldProtect;
		if (!VirtualProtect(&VTable[Index], sizeof(void*), PAGE_EXECUTE_READWRITE, &OldProtect))
			return false;

		VTable[Index] = OriginalFunction;
		VirtualProtect(&VTable[Index], sizeof(void*), OldProtect, &OldProtect);

		bInstalled = false;
		return true;
	}

	template<typename FuncType>
	FuncType GetOriginal() const
	{
		return reinterpret_cast<FuncType>(OriginalFunction);
	}

	bool IsInstalled() const { return bInstalled; }
};

}
